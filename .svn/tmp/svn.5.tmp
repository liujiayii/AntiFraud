layui.use([ 'form' ], function() { // 如果只加载一个模块，可以不填数组。如：layui.use('form')
	var form = layui.form;
})

$(document).keypress(function(e) {
	if ((e.keyCode || e.which) == 13) {
		$("#loginBtn").click(); // login_btn登录按钮的id
	}
});
function login() {
	$.ajax({
		type : "POST", // 提交方式
		dataType : "json", // 预期服务器返回的数据类型
		url : "/loginUser.action", // 目标url
		data : $('#form').serialize(), // 提交的数据
		success : function(result) {
			console.log(result); // 打印服务端返回的数据(调试用)
			if (result.resultCode == 200) {
				alert("成功");
			}
		},
		error : function() {
			alert("异常！");
		}
	});
}
var bConnect = 0;
function load() {
	// 如果是IE10及以下浏览器，则跳过不处理
	if (navigator.userAgent.indexOf("MSIE") > 0 && !navigator.userAgent.indexOf("opera") > -1)
		return;
	try {
		var s_pnp = new SoftKey3W();
		s_pnp.Socket_UK.onopen = function() {
			bConnect = 1;// 代表已经连接，用于判断是否安装了客户端服务
		}

		// 在使用事件插拨时，注意，一定不要关掉Sockey，否则无法监测事件插拨
		s_pnp.Socket_UK.onmessage = function got_packet(Msg) {
			var PnpData = JSON.parse(Msg.data);
			if (PnpData.type == "PnpEvent")// 如果是插拨事件处理消息
			{
				if (PnpData.IsIn) {
					console.log('已执行');
					layer.msg("UKEY已被插入，被插入的锁的路径是：" + PnpData.DevicePath, function() {
					})
				} else {
					layer.msg("UKEY已被拨出，被拨出的锁的路径是：" + PnpData.DevicePath, function() {
					})
				}
			}
		}

		s_pnp.Socket_UK.onclose = function() {

		}
	} catch (e) {
		layer.msg(e.name + ": " + e.message, function() {
		})
		return false;
	}
}

var digitArray = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

function toHex(n) {

	var result = ''
	var start = true;

	for (var i = 32; i > 0;) {
		i -= 4;
		var digit = (n >> i) & 0xf;

		if (!start || digit != 0) {
			start = false;
			result += digitArray[digit];
		}
	}

	return (result == '' ? '0' : result);
}

function login_onclick() {
	console.log('login_onclick');

	// 如果是IE10及以下浏览器，则使用AVCTIVEX控件的方式
	if (navigator.userAgent.indexOf("MSIE") > 0 && !navigator.userAgent.indexOf("opera") > -1)
		return Handle_IE10();

	// 判断是否安装了服务程序，如果没有安装提示用户安装
	if (bConnect == 0) {
		layer.alert("请下载安装安全云盾控件<a href='/riskManagement/lib/SetUp.exe'> [下载控件]</a>", {
			skin : 'layui-layer-lan' // 样式类名
			,
			closeBtn : 0
		});
		return false;
	}

	var DevicePath, ret, n, mylen, ID_1, ID_2, addr;
	try {

		// 由于是使用事件消息的方式与服务程序进行通讯，
		// 好处是不用安装插件，不分系统及版本，控件也不会被拦截，同时安装服务程序后，可以立即使用，不用重启浏览器
		// 不好的地方，就是但写代码会复杂一些
		var s_simnew1 = new SoftKey3W(); // 创建UK类

		s_simnew1.Socket_UK.onopen = function() {
			s_simnew1.ResetOrder();// 这里调用ResetOrder将计数清零，这样，消息处理处就会收到0序号的消息，通过计数及序号的方式，从而生产流程
		}

		// 写代码时一定要注意，每调用我们的一个UKEY函数，就会生产一个计数，即增加一个序号，较好的逻辑是一个序号的消息处理中，只调用我们一个UKEY的函数
		s_simnew1.Socket_UK.onmessage = function got_packet(Msg) {
			var UK_Data = JSON.parse(Msg.data);
			console.log(UK_Data);
			if (UK_Data.type != "Process")
				return;// 如果不是流程处理消息，则跳过
			switch (UK_Data.order) {
			case 0: {
				s_simnew1.FindPort(0);// 发送命令取UK的路径
			}
				break;// !!!!!重要提示，如果在调试中，发现代码不对，一定要注意，是不是少了break,这个少了是很常见的错误
			case 1: {
				if (UK_Data.LastError != 0) {
					layer.msg('未发现加密锁，请插入加密锁', function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				DevicePath = UK_Data.return_value;// 获得返回的UK的路径
				s_simnew1.GetID_1(DevicePath); // 发送命令取ID_1
			}
				break;
			case 2: {
				if (UK_Data.LastError != 0) {
					layer.msg("返回ID号错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				ID_1 = UK_Data.return_value;// 获得返回的UK的ID_1
				s_simnew1.GetID_2(DevicePath); // 发送命令取ID_2
			}
				break;
			case 3: {
				if (UK_Data.LastError != 0) {
					layer.msg("取得ID错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				ID_2 = UK_Data.return_value;// 获得返回的UK的ID_2

				frmlogin.KeyID.value = toHex(ID_1) + toHex(ID_2);

				s_simnew1.ContinueOrder();// 为了方便阅读，这里调用了一句继续下一行的计算的命令，因为在这个消息中没有调用我们的函数，所以要调用这个
			}
				break;
			case 4: {
				// 获取设置在锁中的用户名
				// 先从地址0读取字符串的长度,使用默认的读密码"FFFFFFFF","FFFFFFFF"
				addr = 0;
				s_simnew1.YReadEx(addr, 1, "ffffffff", "ffffffff", DevicePath);// 发送命令取UK地址0的数据
			}
				break;
			case 5: {
				if (UK_Data.LastError != 0) {
					layer.msg("读数据时错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				s_simnew1.GetBuf(0);// 发送命令从数据缓冲区中数据
			}
				break;
			case 6: {
				if (UK_Data.LastError != 0) {
					layer.msg("调用GetBuf时错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				mylen = UK_Data.return_value;// 获得返回的数据缓冲区中数据

				// 再从地址1读取相应的长度的字符串，,使用默认的读密码"FFFFFFFF","FFFFFFFF"
				addr = 1;
				s_simnew1.YReadString(addr, mylen, "ffffffff", "ffffffff", DevicePath);// 发送命令从UK地址1中取字符串
			}
				break;
			case 7: {
				if (UK_Data.LastError != 0) {
					layer.msg("读取字符串时错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				frmlogin.UserName.value = UK_Data.return_value;// 获得返回的UK地址1的字符串

				// 获到设置在锁中的用户密码,
				// 先从地址20读取字符串的长度,使用默认的读密码"FFFFFFFF","FFFFFFFF"
				addr = 20;
				s_simnew1.YReadEx(addr, 1, "ffffffff", "ffffffff", DevicePath);// 发送命令取UK地址20的数据
			}
				break;
			case 8: {
				if (UK_Data.LastError != 0) {
					layer.msg("读取数据时错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				s_simnew1.GetBuf(0);// 发送命令从数据缓冲区中数据
			}
				break;
			case 9: {
				if (UK_Data.LastError != 0) {
					layer.msg("调用GetBuf时错误，错误码为：" + UK_Data.LastError.toString(), function() {
					});
					s_simnew1.Socket_UK.close();
					return false;
				}
				mylen = UK_Data.return_value;// 获得返回的数据缓冲区中数据

				// 再从地址21读取相应的长度的字符串，,使用默认的读密码"FFFFFFFF","FFFFFFFF"
				addr = 21;
				s_simnew1.YReadString(addr, mylen, "ffffffff", "ffffffff", DevicePath);// 发送命令从UK地址21中取字符串
			}
				break;
			case 10: {
				if (UK_Data.LastError != 0) {
					layer.msg("读取字符串时错误，错误码为：" + UK_Data.LastError.toString());
					s_simnew1.Socket_UK.close();
					return false;
				}
				// frmlogin.Password.value=UK_Data.return_value;//获得返回的UK中地址21的字符串

				// frmlogin.DevicePath.value=DevicePath;
				// 这里返回对随机数的HASH结果
				s_simnew1.EncString(frmlogin.rnd.value, DevicePath);// 发送命令让UK进行加密操作
			}
				break;
			case 11: {
				if (UK_Data.LastError != 0) {
					layer.msg("进行加密运行算时错误，错误码为：" + UK_Data.LastError.toString());
					s_simnew1.Socket_UK.close();
					return false;
				}
				frmlogin.return_EncData.value = UK_Data.return_value;// 获得返回的加密后的字符串
				console.log("客户端加密串：" + UK_Data.return_value);
				// !!!!!注意，这里一定要主动提交，
				console.log($('#form').serialize());
				login();

				// 所有工作处理完成后，关掉Socket
				s_simnew1.Socket_UK.close();
			}
				break;
			}
		}
		s_simnew1.Socket_UK.onclose = function() {

		}
		return true;
	} catch (e) {
		layer.msg(e.name + ": " + e.message, function() {
		});
	}

}

function Handle_IE10() {
	try {
		var DevicePath, mylen, ret;
		var s_simnew1;
		// 创建控件

		s_simnew1 = new ActiveXObject("Syunew3A.s_simnew3");

		DevicePath = s_simnew1.FindPort(0);// '来查找加密锁，0是指查找默认端口的锁
		if (s_simnew1.LastError != 0) {
			layer.msg("未发现加密锁，请插入加密锁", function() {
			});
			return false;
		} else {
			// '读取锁的ID
			frmlogin.KeyID.value = toHex(s_simnew1.GetID_1(DevicePath)) + toHex(s_simnew1.GetID_2(DevicePath));
			if (s_simnew1.LastError != 0) {
				layer.msg("获取用户名错误,错误码是" + s_simnew1.LastError.toString(), function() {
				});
				return false;
			}
			// 获取设置在锁中的用户名
			// 先从地址0读取字符串的长度,使用默认的读密码"FFFFFFFF","FFFFFFFF"
			ret = s_simnew1.YReadEx(0, 1, "ffffffff", "ffffffff", DevicePath);
			mylen = s_simnew1.GetBuf(0);
			// 再从地址1读取相应的长度的字符串，,使用默认的读密码"FFFFFFFF","FFFFFFFF"
			frmlogin.UserName.value = s_simnew1.YReadString(1, mylen, "ffffffff", "ffffffff", DevicePath);
			if (s_simnew1.LastError != 0) {
				layer.msg("Err to GetUserName,ErrCode is:" + s_simnew1.LastError.toString(), function() {
				});
				return false;
			}

			// 获到设置在锁中的用户密码,
			// 先从地址20读取字符串的长度,使用默认的读密码"FFFFFFFF","FFFFFFFF"
			ret = s_simnew1.YReadEx(20, 1, "ffffffff", "ffffffff", DevicePath);
			mylen = s_simnew1.GetBuf(0);
			// 再从地址21读取相应的长度的字符串，,使用默认的读密码"FFFFFFFF","FFFFFFFF"
			frmlogin.Password.value = s_simnew1.YReadString(21, mylen, "ffffffff", "ffffffff", DevicePath);
			if (s_simnew1.LastError != 0) {
				layer.msg("获取用户密码错误,错误码是:" + s_simnew1.LastError.toString(), function() {
				});
				return false;
			}

			// frmlogin.submit();
			console.log($('#form').serialize());
			login();
			return true;
		}
	}

	catch (e) {
		layer.msg(e.name + ": " + e.message + "。可能是没有安装相应的控件或插件", function() {
		});
		return false;
	}

}